# 第四章

## 指令学习

* 指令语法形式
* 指令功能
* 对操作数的要求
* 指令对标志寄存器的影响

## 常用指令

* 数据传送
  * 通用数据传送
    * MOV destination,source:原操作数复制一份到目的操作数
      * 两个操作数不能同时为内存量，长时间访问内存，降低性能
      * 两个操作数长度一致，立即数不可用作source
      * 若某一个操作数长度已知，而另一个操作数的长度则可以根据其指定长度
      * 目的数：不能是立即数，可以是寄存器变量、存储器。EIP，CS，IP不可使用，由于其关系到当前的执行代码
    * 零扩展：补充0
    * 符号扩展：补充符号位，例如80H进行扩展，若要保留其为-128的值，则可进行符号扩展
    * MOVZX:原操作数0扩展后复制到目的操作数
      * 目的操作数为reg
    * MOVSX:原操作数符号扩展后复制到目的操作数
      * 目的操作数为reg
    * XCHG:交换操作数的值
      * 至少一个操作数为寄存器，不允许使用立即数
    
  * 堆栈操作
    * 压栈：ESP减
    * 弹栈：ESP加
    * PUSH、POP
    * PUSHFD、POPFD　３２位下 对标志寄存器有影响，即影响标志位
    * PUSHF、POPF　１６位下
    * PUSHAD、POPAD
    
  * LEA/LDS/LES 即数，必须为32位，因为地址为32位。
    * * 操作数支持更多寻址方式，OFFSET仅为伪指令
      
    * LDS：
  
* 算逻运算

  * 加法

    * ADD
      * ADD时，看作无符号数相加。结果未超出正/负数的表示范围时，OF不变。若超出所有位的表示范围(包括符号位)，则有CF
    * INC：自增操作或自建操作不影响CF标志

    * ADC：带进位的加法
  * 减法

    * SUB
    * DEC
    * SBB
    * NEG
      * 求补操作。1的补码是-1
    * CMP：既实现有符号数的比较（称大小），也实现了无符号数比较（称高低）
    * ADD和SUB会影响全部标志位
  * 乘法
    * MUL
      * 无符号乘AL/AX/EAX
      * MUL r/m8/16/32
      * 若CF为1，则不可舍弃乘积高半位
    * IMUL
      * 有符号乘AL/AX/EAX
      * 若OF为1，则不可舍弃乘积高半位
      * 双操作数时，IMUL操作数可以为立即数，目的操作数只能为寄存器，当目的操作数无法存放乘积时，OF=CF=1

  * 除法
    * DIV
      * 无符号除法
      * 当商不能包含在目标操作数内，发生除法溢出
    * IDIV
    * 扩展指令
      * CBW
        * 把字节变成字，将AL的最高位复制到AH的每一位
      * CWD
        * 把字变成双字，将AX的最高位复制到EAX的每一位
      * 都是无操作数指令，使用了默认寄存器
    * 调整指令
      * 非压缩
        * AAA：ASCII加法调整
        * AAS：ASCII减法调整
        * AAM：ASCII乘法调整
        * AAD：ASCII除法调整
      * 压缩
        * DAA
        * DAS
  * 逻辑运算
    * AND
    * OR
    * XOR
    * TEST
      * 是一个AND，但两个操作数内容不会变化，但保留标志位
    * 不能同时为mem
    * bit-mapped sets
    * BT(chap7 37)
      * BT bitbase,n

* 流程控制

  * 分支
    * 无条件跳转JMP
    * 有条件跳转(chap6 p22)
      * 有符号数条件跳转
        * JG/JNLE
          * G：greater大于 NLE：not less or equal
        * JGE/JNL
        * JE/JZ
        * JL/JNGE
        * JLE/JNG
        * JNE/JNZ
      * 无符号数跳转
        * JA/JNBE
          * A:above B:below 
        * JAE/JNB
        * JB/JNAE
        * JBE/JNA
      * 标志位跳转
        * JC/JNC
          * jump CF=1 / jump CF!=1
        * JS/JNS
        * JZ/JNZ
        * JP/JNP
        * JO/JNO
      * CX/ECX
        * JCXZ/JECXZ
  * 循环
    * 无条件循环LOOP
      * 每次ECX-1直到ECX=0
    * 有条件循环
      * LOOPZ/LOOPE
        * 条件：ECX>0且ZF=1
      * LOOPNZ/LOOPNE
        * 条件：ECX>0且ZF=0

* 移位运算

  * RCL

    * 左移，移出的位送入CF，移入的位补充原来CF位，即补充原来移出的位
    * 带CF位

  * RCR

    * 右移，移出的位送入CF，移入的位补充原来CF位，即补充原来移出的位
    * 带CF位

  * ROL

    * 循环左移

  * ROR

    * 循环右移下

  * SHL/SAL

    * 普通左移，移走最高位，不分算术和逻辑

  * SHR

    * 逻辑右移

    * 右移移出的最低一位送至CF，最高位补充0

  * SAR

    * 算术右移
    * 右移移出的最低一位送至CF，最高位补充原来的最高位

  * SHLD

    * 三操作数，共同左移，第三个操作数为指定移位的位数
    * 移出的位存入CF，空缺位有原操作数的最高位补充
    * CF保存的是最后移出的一位

  * SHRD

    * 三操作数，共同右移，第三个操作数为指定移位的位数
    * 移出的位存入CF，空缺位有原操作数的最高位补充
    * CF保存的是最后移出的一位

* 串处理

* 系统控制

